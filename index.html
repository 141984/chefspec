<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>ChefSpec by sethvargo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">ChefSpec</h1>
      <h2 class="project-tagline">Write RSpec examples and generate coverage reports for Chef recipes!</h2>
      <a href="https://github.com/sethvargo/chefspec" class="btn">View on GitHub</a>
      <a href="https://github.com/sethvargo/chefspec/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/sethvargo/chefspec/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="chefspec" class="anchor" href="#chefspec" aria-hidden="true"><span class="octicon octicon-link"></span></a>ChefSpec</h1>

<p><a href="https://rubygems.org/gems/chefspec"><img src="http://img.shields.io/gem/v/chefspec.svg" alt="Gem Version"></a>
<a href="http://travis-ci.org/sethvargo/chefspec"><img src="http://img.shields.io/travis/sethvargo/chefspec.svg" alt="Build Status"></a></p>

<p>ChefSpec is a unit testing framework for testing Chef cookbooks. ChefSpec makes it easy to write examples and get fast feedback on cookbook changes without the need for virtual machines or cloud servers.</p>

<p>ChefSpec runs your cookbook(s) locally with Chef Solo without actually converging a node. This has two primary benefits:</p>

<ul>
<li>It's really fast!</li>
<li>Your tests can vary node attributes, operating systems, and search results to assert behavior under varying conditions.</li>
</ul>

<h2>
<a id="what-people-are-saying" class="anchor" href="#what-people-are-saying" aria-hidden="true"><span class="octicon octicon-link"></span></a>What people are saying</h2>

<blockquote>
<p>I just wanted to drop you a line to say "HELL YES!" to ChefSpec. - <a href="https://twitter.com/jgoggins">Joe Goggins</a></p>

<p>OK ChefSpec is my new best friend. Delightful few hours working with it. - <a href="https://twitter.com/ivey">Michael Ivey</a></p>
</blockquote>

<p><strong>Chat with us - #chefspec on Freenode</strong></p>

<h2>
<a id="important-notes" class="anchor" href="#important-notes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Important Notes</h2>

<ul>
<li><strong>ChefSpec 3.0+ requires Ruby 1.9 or higher!</strong></li>
<li><strong>This documentation corresponds to the master branch, which may be unreleased. Please check the README of the latest git tag or the gem's source for your version's documentation!</strong></li>
<li><strong>Each resource matcher is self-documented using <a href="http://rubydoc.info/github/sethvargo/chefspec">Yard</a> and has a corresponding aruba test from the <a href="https://github.com/sethvargo/chefspec/tree/master/examples">examples directory</a>.</strong></li>
<li>
<strong>ChefSpec aims to maintain compatability with the two most recent minor versions of Chef.</strong> If you are running an older version of Chef it may work, or you will need to run an older version of ChefSpec.</li>
</ul>

<h2>
<a id="notes-on-compatability-with-chef-versions" class="anchor" href="#notes-on-compatability-with-chef-versions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Notes on Compatability with Chef Versions</h2>

<p>As a general rule, if it is tested in the Travis CI matrix, it is a supported version. The section below details any specific versions that are <em>not</em> supported and why:</p>

<ul>
<li>Chef 12 prior to Chef 12.0.2 is not supported due to the lack of a declared resource type. This was fixed in <a href="https://github.com/chef/chef/blob/12.0.2/lib/chef/resource.rb#L422-428">Chef 12.0.2</a>.</li>
</ul>

<p>Additionally, if you look at a cucumber feature and see a tag like <code>@not_chef_x_y_z</code>, that means that particular functionality is not supported on those versions of Chef.</p>

<h2>
<a id="writing-a-cookbook-example" class="anchor" href="#writing-a-cookbook-example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Writing a Cookbook Example</h2>

<p>If you want <code>knife</code> to automatically generate spec stubs for you, install <a href="https://github.com/sethvargo/knife-spec">knife-spec</a>.</p>

<p>Given an extremely basic Chef recipe that just installs an operating system package:</p>

<div class="highlight highlight-ruby"><pre>package <span class="pl-s"><span class="pl-pds">'</span>foo<span class="pl-pds">'</span></span></pre></div>

<p>the associated ChefSpec test might look like:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">'</span>chefspec<span class="pl-pds">'</span></span>

describe <span class="pl-s"><span class="pl-pds">'</span>example::default<span class="pl-pds">'</span></span> <span class="pl-k">do</span>
  let(<span class="pl-c1">:chef_run</span>) { <span class="pl-c1">ChefSpec</span>::<span class="pl-c1">SoloRunner</span>.converge(described_recipe) }

  it <span class="pl-s"><span class="pl-pds">'</span>installs foo<span class="pl-pds">'</span></span> <span class="pl-k">do</span>
    expect(chef_run).to install_package(<span class="pl-s"><span class="pl-pds">'</span>foo<span class="pl-pds">'</span></span>)
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>Let's step through this file to see what is happening:</p>

<ol>
<li>At the top of the spec file we require the chefspec gem. This is required so that our custom matchers are loaded. In larger projects, it is common practice to create a file named "spec_helper.rb" and include ChefSpec and perform other setup tasks in that file.</li>
<li>The <code>describe</code> keyword is part of RSpec and indicates that everything nested beneath is describing the <code>example::default</code> recipe. The convention is to have a separate spec for each recipe in your cookbook.</li>
<li>The <code>let</code> block on creates the <code>ChefSpec:Runner</code> and then does a fake Chef run with the run_list of <code>example::default</code>. Any subsequent examples can then refer to <code>chef_run</code> in order to make assertions about the resources that were created during the mock converge.</li>
<li>The <code>described_recipe</code> macro is a ChefSpec helper method that infers the recipe from the <code>describe</code> block. Alternatively you could specify the recipe directly.</li>
<li>The <code>it</code> block is an example specifying that the <code>foo</code> package is installed. Normally you will have multiple <code>it</code> blocks per recipe, each making a single assertion.</li>
</ol>

<h2>
<a id="configuration" class="anchor" href="#configuration" aria-hidden="true"><span class="octicon octicon-link"></span></a>Configuration</h2>

<p>ChefSpec exposes a configuration layer at the global level and at the <code>Runner</code> level. The following settings are available:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-c1">RSpec</span>.configure <span class="pl-k">do </span>|<span class="pl-smi">config</span>|
  <span class="pl-c"># Specify the path for Chef Solo to find cookbooks (default: [inferred from</span>
  <span class="pl-c"># the location of the calling spec file])</span>
  config.cookbook_path <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>/var/cookbooks<span class="pl-pds">'</span></span>

  <span class="pl-c"># Specify the path for Chef Solo to find roles (default: [ascending search])</span>
  config.role_path <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>/var/roles<span class="pl-pds">'</span></span>

  <span class="pl-c"># Specify the path for Chef Solo to find environments (default: [ascending search])</span>
  config.environment_path <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>/var/environments<span class="pl-pds">'</span></span>

  <span class="pl-c"># Specify the path for Chef Solo file cache path (default: nil)</span>
  config.file_cache_path <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>/var/chef/cache<span class="pl-pds">'</span></span>

  <span class="pl-c"># Specify the Chef log_level (default: :warn)</span>
  config.log_level <span class="pl-k">=</span> <span class="pl-c1">:debug</span>

  <span class="pl-c"># Specify the path to a local JSON file with Ohai data (default: nil)</span>
  config.path <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>ohai.json<span class="pl-pds">'</span></span>

  <span class="pl-c"># Specify the operating platform to mock Ohai data from (default: nil)</span>
  config.platform <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>ubuntu<span class="pl-pds">'</span></span>

  <span class="pl-c"># Specify the operating version to mock Ohai data from (default: nil)</span>
  config.version <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>12.04<span class="pl-pds">'</span></span>
<span class="pl-k">end</span></pre></div>

<p>Values specified at the initialization of a "Runner" merge and take precedence over any global settings:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-c"># Override only the operating system version (platform is still "ubuntu" from above)</span>
<span class="pl-c1">ChefSpec</span>::<span class="pl-c1">SoloRunner</span>.<span class="pl-k">new</span>(<span class="pl-c1">version:</span> <span class="pl-s"><span class="pl-pds">'</span>10.04<span class="pl-pds">'</span></span>)

<span class="pl-c"># Use a different operating system platform and version</span>
<span class="pl-c1">ChefSpec</span>::<span class="pl-c1">SoloRunner</span>.<span class="pl-k">new</span>(<span class="pl-c1">platform:</span> <span class="pl-s"><span class="pl-pds">'</span>centos<span class="pl-pds">'</span></span>, <span class="pl-c1">version:</span> <span class="pl-s"><span class="pl-pds">'</span>5.10<span class="pl-pds">'</span></span>)

<span class="pl-c"># Specify a different cookbook_path</span>
<span class="pl-c1">ChefSpec</span>::<span class="pl-c1">SoloRunner</span>.<span class="pl-k">new</span>(<span class="pl-c1">cookbook_path:</span> <span class="pl-s"><span class="pl-pds">'</span>/var/my/other/path<span class="pl-pds">'</span></span>, <span class="pl-c1">role_path:</span> <span class="pl-s"><span class="pl-pds">'</span>/var/my/roles<span class="pl-pds">'</span></span>)

<span class="pl-c"># By default ChefSpec sets a new temporary directory for file caching in every run.</span>
<span class="pl-c"># This can be overridden by passing the `file_cache_path` option.</span>
<span class="pl-c"># Note: Resources containing `Chef::Config[:file_cache_path]` in their name or</span>
<span class="pl-c"># attributes, will fail unless this option is specified.</span>
<span class="pl-c1">ChefSpec</span>::<span class="pl-c1">SoloRunner</span>.<span class="pl-k">new</span>(<span class="pl-c1">file_cache_path:</span> <span class="pl-s"><span class="pl-pds">'</span>/var/chef/cache<span class="pl-pds">'</span></span>)

<span class="pl-c"># Add debug log output</span>
<span class="pl-c1">ChefSpec</span>::<span class="pl-c1">SoloRunner</span>.<span class="pl-k">new</span>(<span class="pl-c1">log_level:</span> <span class="pl-c1">:debug</span>).converge(described_recipe)</pre></div>

<p><strong>NOTE</strong> You do not <em>need</em> to specify a platform and version to use ChefSpec. However, some cookbooks may rely on <a href="http://github.com/opscode/ohai">Ohai</a> data that ChefSpec cannot not automatically generate. Specifying the <code>platform</code> and <code>version</code> keys instructs ChefSpec to load stubbed Ohai attributes from another platform using <a href="https://github.com/customink/fauxhai">fauxhai</a>.</p>

<h3>
<a id="berkshelf" class="anchor" href="#berkshelf" aria-hidden="true"><span class="octicon octicon-link"></span></a>Berkshelf</h3>

<p>If you are using Berkshelf, simply require <code>chefspec/berkshelf</code> in your <code>spec_helper</code> after requiring <code>chefspec</code>:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-c"># spec_helper.rb</span>
<span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">'</span>chefspec<span class="pl-pds">'</span></span>
<span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">'</span>chefspec/berkshelf<span class="pl-pds">'</span></span></pre></div>

<p>Requiring this file will:</p>

<ul>
<li>Create a temporary working directory</li>
<li>Download all the dependencies listed in your <code>Berksfile</code> into the temporary directory</li>
<li>Set ChefSpec's <code>cookbook_path</code> to the temporary directory</li>
</ul>

<h3>
<a id="librarian" class="anchor" href="#librarian" aria-hidden="true"><span class="octicon octicon-link"></span></a>Librarian</h3>

<p>If you are using Librarian, simply require <code>chefspec/librarian</code> in your <code>spec_helper</code> after requiring <code>chefspec</code>:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-c"># spec_helper.rb</span>
<span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">'</span>chefspec<span class="pl-pds">'</span></span>
<span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">'</span>chefspec/librarian<span class="pl-pds">'</span></span></pre></div>

<p>Requiring this file will:</p>

<ul>
<li>Create a temporary working directory</li>
<li>Download all the dependencies listed in your <code>Cheffile</code> into the temporary directory</li>
<li>Set ChefSpec's <code>cookbook_path</code> to the temporary directory</li>
</ul>

<p><strong>NOTE</strong> In order to test the cookbook in the current working directory, you
have to write your <code>Cheffile</code> like this:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-c"># Cheffile</span>
site <span class="pl-s"><span class="pl-pds">'</span>http://community.opscode.com/api/v1<span class="pl-pds">'</span></span>

cookbook <span class="pl-s"><span class="pl-pds">'</span>name_of_your_cookbook<span class="pl-pds">'</span></span>, <span class="pl-c1">path:</span> <span class="pl-s"><span class="pl-pds">'</span>.<span class="pl-pds">'</span></span></pre></div>

<h2>
<a id="running-specs" class="anchor" href="#running-specs" aria-hidden="true"><span class="octicon octicon-link"></span></a>Running Specs</h2>

<p>ChefSpec is actually an RSpec extension, so you can run your tests using the RSpec CLI:</p>

<div class="highlight highlight-bash"><pre>$ rspec</pre></div>

<p>You can also specify a specific spec to run and various RSpec command line options:</p>

<div class="highlight highlight-bash"><pre>$ rspec spec/unit/recipes/default_spec.rb --color</pre></div>

<p>For more information on the RSpec CLI, please see the <a href="https://relishapp.com/rspec/rspec-core/docs/command-line">documentation</a>.</p>

<h2>
<a id="making-assertions" class="anchor" href="#making-assertions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Making Assertions</h2>

<p>ChefSpec asserts that resource actions have been performed. In general, ChefSpec follows the following pattern:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">'</span>chefspec<span class="pl-pds">'</span></span>

describe <span class="pl-s"><span class="pl-pds">'</span>example::default<span class="pl-pds">'</span></span> <span class="pl-k">do</span>
  let(<span class="pl-c1">:chef_run</span>) { <span class="pl-c1">ChefSpec</span>::<span class="pl-c1">SoloRunner</span>.converge(described_recipe) }

  it <span class="pl-s"><span class="pl-pds">'</span>does something<span class="pl-pds">'</span></span> <span class="pl-k">do</span>
    expect(chef_run).to <span class="pl-c1">ACTION_RESOURCE</span>(<span class="pl-c1">NAME</span>)
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>where:</p>

<ul>
<li>
<em>ACTION</em> - the action on the resource (e.g. <code>install</code>)</li>
<li>
<em>RESOURCE</em> - the name of the resource (e.g. <code>package</code>)</li>
<li>
<em>NAME</em> - the name attribute for the resource (e.g. <code>apache2</code>)</li>
</ul>

<p><strong>NOTE</strong> One exception to this rule is the <code>create_if_missing</code> action on the <code>file</code> resource. In this case the assertion is actually <code>create_file_if_missing</code>. Refer to <code>examples/file/spec/create_if_missing_spec.rb</code> for some examples.</p>

<p>Here's a more concrete example:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">'</span>chefspec<span class="pl-pds">'</span></span>

describe <span class="pl-s"><span class="pl-pds">'</span>example::default<span class="pl-pds">'</span></span> <span class="pl-k">do</span>
  let(<span class="pl-c1">:chef_run</span>) { <span class="pl-c1">ChefSpec</span>::<span class="pl-c1">SoloRunner</span>.converge(described_recipe) }

  it <span class="pl-s"><span class="pl-pds">'</span>does something<span class="pl-pds">'</span></span> <span class="pl-k">do</span>
    expect(chef_run).to install_package(<span class="pl-s"><span class="pl-pds">'</span>apache2<span class="pl-pds">'</span></span>)
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>This test is asserting that the Chef run will have a <em>package</em> resource with the name <em>apache2</em> with an action of <em>install</em>.</p>

<p>To test that a resource action is performed with a specific set of attributes, you can call <code>with(ATTRIBUTES_HASH)</code> on the expectation, per the following example:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">'</span>chefspec<span class="pl-pds">'</span></span>

describe <span class="pl-s"><span class="pl-pds">'</span>example::default<span class="pl-pds">'</span></span> <span class="pl-k">do</span>
  let(<span class="pl-c1">:chef_run</span>) { <span class="pl-c1">ChefSpec</span>::<span class="pl-c1">SoloRunner</span>.converge(described_recipe) }

  it <span class="pl-s"><span class="pl-pds">'</span>does something<span class="pl-pds">'</span></span> <span class="pl-k">do</span>
    expect(chef_run).to modify_group(<span class="pl-s"><span class="pl-pds">'</span>docker<span class="pl-pds">'</span></span>).with(<span class="pl-c1">members:</span> [<span class="pl-s"><span class="pl-pds">'</span>vagrant<span class="pl-pds">'</span></span>])
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>This test is asserting that the Chef run will have a <em>group</em> resource with the name <em>docker</em>, an action of <em>modify</em>, and an attributes hash including <code>{ members: ['vagrant'] }</code>.</p>

<p>ChefSpec includes matchers for all of Chef's core resources using the above schema. Each resource matcher is self-documented using <a href="http://rubydoc.info/github/sethvargo/chefspec">Yard</a> and has a corresponding cucumber test from the <a href="https://github.com/sethvargo/chefspec/tree/master/examples">examples directory</a>.</p>

<p>Additionally, ChefSpec includes the following helpful matchers. They are also <a href="http://rubydoc.info/github/sethvargo/chefspec">documented in Yard</a>, but they are included here because they do not follow the "general pattern".</p>

<h5>
<a id="include_recipe" class="anchor" href="#include_recipe" aria-hidden="true"><span class="octicon octicon-link"></span></a>include_recipe</h5>

<p>Assert that the Chef run included a recipe from another cookbook</p>

<div class="highlight highlight-ruby"><pre>expect(chef_run).to include_recipe(<span class="pl-s"><span class="pl-pds">'</span>other_cookbook::recipe<span class="pl-pds">'</span></span>)</pre></div>

<p>Keep the resources from an included recipe from being loaded into the Chef run, but test that the recipe was included</p>

<div class="highlight highlight-ruby"><pre>describe <span class="pl-s"><span class="pl-pds">'</span>example::default<span class="pl-pds">'</span></span> <span class="pl-k">do</span>
  let(<span class="pl-c1">:chef_run</span>) { <span class="pl-c1">ChefSpec</span>::<span class="pl-c1">SoloRunner</span>.converge(described_recipe) }

  before <span class="pl-k">do</span>
    allow_any_instance_of(<span class="pl-c1">Chef</span>::<span class="pl-c1">Recipe</span>).to receive(<span class="pl-c1">:include_recipe</span>).and_call_original
    allow_any_instance_of(<span class="pl-c1">Chef</span>::<span class="pl-c1">Recipe</span>).to receive(<span class="pl-c1">:include_recipe</span>).with(<span class="pl-s"><span class="pl-pds">'</span>other_cookbook::default<span class="pl-pds">'</span></span>)
  <span class="pl-k">end</span>

  it <span class="pl-s"><span class="pl-pds">'</span>includes the other_cookbook<span class="pl-pds">'</span></span> <span class="pl-k">do</span>
    expect_any_instance_of(<span class="pl-c1">Chef</span>::<span class="pl-c1">Recipe</span>).to receive(<span class="pl-c1">:include_recipe</span>).with(<span class="pl-s"><span class="pl-pds">'</span>other_cookbook::default<span class="pl-pds">'</span></span>)
    chef_run
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<h5>
<a id="notify" class="anchor" href="#notify" aria-hidden="true"><span class="octicon octicon-link"></span></a>notify</h5>

<p>Assert that a resource notifies another in the Chef run</p>

<div class="highlight highlight-ruby"><pre>resource <span class="pl-k">=</span> chef_run.template(<span class="pl-s"><span class="pl-pds">'</span>/etc/foo<span class="pl-pds">'</span></span>)
expect(resource).to notify(<span class="pl-s"><span class="pl-pds">'</span>service[apache2]<span class="pl-pds">'</span></span>).to(<span class="pl-c1">:restart</span>).immediately</pre></div>

<h5>
<a id="subscribes" class="anchor" href="#subscribes" aria-hidden="true"><span class="octicon octicon-link"></span></a>subscribes</h5>

<p>Assert that a resource subscribes to another in the Chef run</p>

<div class="highlight highlight-ruby"><pre>resource <span class="pl-k">=</span> chef_run.service(<span class="pl-s"><span class="pl-pds">'</span>apache2<span class="pl-pds">'</span></span>)
expect(resource).to subscribe_to(<span class="pl-s"><span class="pl-pds">'</span>template[/etc/foo]<span class="pl-pds">'</span></span>).on(<span class="pl-c1">:create</span>).delayed</pre></div>

<h5>
<a id="render_file" class="anchor" href="#render_file" aria-hidden="true"><span class="octicon octicon-link"></span></a>render_file</h5>

<p>Assert that the Chef run renders a file (with optional content); this will match <code>cookbook_file</code>, <code>file</code>, and <code>template</code> resources and can also check the resulting content</p>

<div class="highlight highlight-ruby"><pre>expect(chef_run).to render_file(<span class="pl-s"><span class="pl-pds">'</span>/etc/foo<span class="pl-pds">'</span></span>)
expect(chef_run).to render_file(<span class="pl-s"><span class="pl-pds">'</span>/etc/foo<span class="pl-pds">'</span></span>).with_content(<span class="pl-s"><span class="pl-pds">'</span>This is content<span class="pl-pds">'</span></span>)
expect(chef_run).to render_file(<span class="pl-s"><span class="pl-pds">'</span>/etc/foo<span class="pl-pds">'</span></span>).with_content(<span class="pl-sr"><span class="pl-pds">/</span>regex works too.+<span class="pl-pds">/</span></span>)
expect(chef_run).to render_file(<span class="pl-s"><span class="pl-pds">'</span>/etc/foo<span class="pl-pds">'</span></span>).with_content { |<span class="pl-smi">content</span>|
  <span class="pl-c"># Regular RSpec matches work in here</span>
  expect(content).to <span class="pl-k">include</span>(<span class="pl-s"><span class="pl-pds">'</span>any RSpec matcher<span class="pl-pds">'</span></span>)
}</pre></div>

<p>You can use any RSpec content matcher inside of the <code>with_content</code> predicate:</p>

<div class="highlight highlight-ruby"><pre>expect(chef_run).to render_file(<span class="pl-s"><span class="pl-pds">'</span>/etc/foo<span class="pl-pds">'</span></span>).with_content(start_with(<span class="pl-s"><span class="pl-pds">'</span># First line<span class="pl-pds">'</span></span>))</pre></div>

<p>It is possible to assert which <a href="http://docs.opscode.com/essentials_nodes_chef_run.html">Chef phase of execution</a> a resource is created. Given a resource that is installed at compile time using <code>run_action</code>:</p>

<div class="highlight highlight-ruby"><pre>package(<span class="pl-s"><span class="pl-pds">'</span>apache2<span class="pl-pds">'</span></span>).run_action(<span class="pl-c1">:install</span>)</pre></div>

<p>You can assert that this package is installed during runtime using the <code>.at_compile_time</code> predicate on the resource matcher:</p>

<div class="highlight highlight-ruby"><pre>expect(chef_run).to install_package(<span class="pl-s"><span class="pl-pds">'</span>apache2<span class="pl-pds">'</span></span>).at_compile_time</pre></div>

<p>Similarly, you can assert that a resource is executed during convergence time:</p>

<div class="highlight highlight-ruby"><pre>expect(chef_run).to install_package(<span class="pl-s"><span class="pl-pds">'</span>apache2<span class="pl-pds">'</span></span>).at_converge_time</pre></div>

<p>Since "converge time" is the default behavior for all recipes, this test might be redundant and the predicate could be dropped depending on your situation.</p>

<h5>
<a id="do_nothing" class="anchor" href="#do_nothing" aria-hidden="true"><span class="octicon octicon-link"></span></a>do_nothing</h5>

<p>Assert that a resource performs no action</p>

<div class="highlight highlight-ruby"><pre>resource <span class="pl-k">=</span> chef_run.execute(<span class="pl-s"><span class="pl-pds">'</span>install<span class="pl-pds">'</span></span>)
expect(resource).to do_nothing</pre></div>

<p><strong>For more complex examples, please see the <a href="https://github.com/sethvargo/chefspec/tree/master/examples">examples directory</a> or the <a href="http://rubydoc.info/github/sethvargo/chefspec">Yard documentation</a>.</strong></p>

<h2>
<a id="setting-node-attributes" class="anchor" href="#setting-node-attributes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Setting node Attributes</h2>

<p>Node attribute can be set when creating the <code>Runner</code>. The initializer yields a block that gives full access to the node object:</p>

<div class="highlight highlight-ruby"><pre>describe <span class="pl-s"><span class="pl-pds">'</span>example::default<span class="pl-pds">'</span></span> <span class="pl-k">do</span>
  let(<span class="pl-c1">:chef_run</span>) <span class="pl-k">do</span>
    <span class="pl-c1">ChefSpec</span>::<span class="pl-c1">SoloRunner</span>.<span class="pl-k">new</span> <span class="pl-k">do </span>|<span class="pl-smi">node</span>|
      node.set[<span class="pl-s"><span class="pl-pds">'</span>cookbook<span class="pl-pds">'</span></span>][<span class="pl-s"><span class="pl-pds">'</span>attribute<span class="pl-pds">'</span></span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>hello<span class="pl-pds">'</span></span>
    <span class="pl-k">end</span>.converge(described_recipe)
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<h3>
<a id="automatic-attributes" class="anchor" href="#automatic-attributes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Automatic attributes</h3>

<p>ChefSpec provides mocked automatic Ohai data using <a href="https://github.com/customink/fauxhai">fauxhai</a>. To mock out <code>automatic</code> attributes, you must use the <code>automatic</code> key:</p>

<div class="highlight highlight-ruby"><pre>describe <span class="pl-s"><span class="pl-pds">'</span>example::default<span class="pl-pds">'</span></span> <span class="pl-k">do</span>
  let(<span class="pl-c1">:chef_run</span>) <span class="pl-k">do</span>
    <span class="pl-c1">ChefSpec</span>::<span class="pl-c1">SoloRunner</span>.<span class="pl-k">new</span> <span class="pl-k">do </span>|<span class="pl-smi">node</span>|
      node.automatic[<span class="pl-s"><span class="pl-pds">'</span>memory<span class="pl-pds">'</span></span>][<span class="pl-s"><span class="pl-pds">'</span>total<span class="pl-pds">'</span></span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>512kB<span class="pl-pds">'</span></span>
    <span class="pl-k">end</span>.converge(described_recipe)
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>The <code>node</code> that is returned is actually a <a href="http://docs.opscode.com/essentials_node_object.html"><code>Chef::Node</code></a> object.</p>

<p>To set an attribute within a specific test, set the attribute in the <code>it</code> block and then <strong>(re-)converge the node</strong>:</p>

<div class="highlight highlight-ruby"><pre>describe <span class="pl-s"><span class="pl-pds">'</span>example::default<span class="pl-pds">'</span></span> <span class="pl-k">do</span>
  let(<span class="pl-c1">:chef_run</span>) { <span class="pl-c1">ChefSpec</span>::<span class="pl-c1">SoloRunner</span>.<span class="pl-k">new</span> } <span class="pl-c"># Notice we don't converge here</span>

  it <span class="pl-s"><span class="pl-pds">'</span>performs the action<span class="pl-pds">'</span></span> <span class="pl-k">do</span>
    chef_run.node.set[<span class="pl-s"><span class="pl-pds">'</span>cookbook<span class="pl-pds">'</span></span>][<span class="pl-s"><span class="pl-pds">'</span>attribute<span class="pl-pds">'</span></span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>hello<span class="pl-pds">'</span></span>
    chef_run.converge(described_recipe) <span class="pl-c"># The converge happens inside the test</span>

    expect(chef_run).to do_something
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<h2>
<a id="using-a-chef-server" class="anchor" href="#using-a-chef-server" aria-hidden="true"><span class="octicon octicon-link"></span></a>Using a Chef Server</h2>

<p>All the examples thus far have used the <code>ChefSpec::SoloRunner</code>, which runs ChefSpec in Chef Solo mode. ChefSpec also includes the ability to create in-memory Chef Servers. This server can be populated with fake data and used to test search, data bags, and other "server-only" features.</p>

<p>To use the ChefSpec server, simply replace <code>ChefSpec::SoloRunner</code> with <code>ChefSpec::ServerRunner</code>:</p>

<div class="highlight highlight-diff"><pre>describe 'example::default' do
<span class="pl-md">-  let(:chef_run) { ChefSpec::SoloRunner.converge(described_recipe) }</span>
<span class="pl-mi1">+  let(:chef_run) { ChefSpec::ServerRunner.converge(described_recipe) }</span>
end</pre></div>

<p>This will automatically create a Chef Server, synchronize all the cookbooks in your <code>cookbook_path</code>, and wire all the internals of Chef together. Recipe calls to <code>search</code>, <code>data_bag</code> and <code>data_bag_item</code> will now query this ChefSpec server.</p>

<h3>
<a id="dsl" class="anchor" href="#dsl" aria-hidden="true"><span class="octicon octicon-link"></span></a>DSL</h3>

<p>The ChefSpec server includes a collection of helpful DSL methods for populating data into the Chef Server.</p>

<p>Create a client:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-c1">ChefSpec</span>::<span class="pl-c1">ServerRunner</span>.<span class="pl-k">new</span> <span class="pl-k">do </span>|<span class="pl-smi">node</span>, <span class="pl-smi">server</span>|
  server.create_client(<span class="pl-s"><span class="pl-pds">'</span>my_client<span class="pl-pds">'</span></span>, { <span class="pl-c1">admin:</span> <span class="pl-c1">true</span> })
<span class="pl-k">end</span></pre></div>

<p>Create a data bag (and items):</p>

<div class="highlight highlight-ruby"><pre><span class="pl-c1">ChefSpec</span>::<span class="pl-c1">ServerRunner</span>.<span class="pl-k">new</span> <span class="pl-k">do </span>|<span class="pl-smi">node</span>, <span class="pl-smi">server</span>|
  server.create_data_bag(<span class="pl-s"><span class="pl-pds">'</span>my_data_bag<span class="pl-pds">'</span></span>, {
    <span class="pl-s"><span class="pl-pds">'</span>item_1<span class="pl-pds">'</span></span> =&gt; {
      <span class="pl-s"><span class="pl-pds">'</span>password<span class="pl-pds">'</span></span> =&gt; <span class="pl-s"><span class="pl-pds">'</span>abc123<span class="pl-pds">'</span></span>
    },
    <span class="pl-s"><span class="pl-pds">'</span>item_2<span class="pl-pds">'</span></span> =&gt; {
      <span class="pl-s"><span class="pl-pds">'</span>password<span class="pl-pds">'</span></span> =&gt; <span class="pl-s"><span class="pl-pds">'</span>def456<span class="pl-pds">'</span></span>
    }
  })
<span class="pl-k">end</span></pre></div>

<p>Create an environment:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-c1">ChefSpec</span>::<span class="pl-c1">ServerRunner</span>.<span class="pl-k">new</span> <span class="pl-k">do </span>|<span class="pl-smi">node</span>, <span class="pl-smi">server</span>|
  server.create_environment(<span class="pl-s"><span class="pl-pds">'</span>my_environment<span class="pl-pds">'</span></span>, { <span class="pl-c1">description:</span> <span class="pl-s"><span class="pl-pds">'</span>...<span class="pl-pds">'</span></span> })
<span class="pl-k">end</span></pre></div>

<p>Create a node:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-c1">ChefSpec</span>::<span class="pl-c1">ServerRunner</span>.<span class="pl-k">new</span> <span class="pl-k">do </span>|<span class="pl-smi">node</span>, <span class="pl-smi">server</span>|
  server.create_node(<span class="pl-s"><span class="pl-pds">'</span>my_node<span class="pl-pds">'</span></span>, { <span class="pl-c1">run_list:</span> [<span class="pl-s"><span class="pl-pds">'</span>...<span class="pl-pds">'</span></span>] })
<span class="pl-k">end</span></pre></div>

<p>Note: the current "node" is always uploaded to the server. However, due to the way the Chef Client compiles cookbooks, you must update the current node on the server if any attributes are changed:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-c1">ChefSpec</span>::<span class="pl-c1">ServerRunner</span>.<span class="pl-k">new</span> <span class="pl-k">do </span>|<span class="pl-smi">node</span>, <span class="pl-smi">server</span>|
  node.set[<span class="pl-s"><span class="pl-pds">'</span>attribute<span class="pl-pds">'</span></span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>value<span class="pl-pds">'</span></span>

  <span class="pl-c"># At this point, the server already has a copy of the current node object due</span>
  <span class="pl-c"># to the way Chef compiled the resources. However, that node does not have</span>
  <span class="pl-c"># this new value. As such, you must "save" the node back to the server to</span>
  <span class="pl-c"># persist this attribute update.</span>
  server.update_node(node)
<span class="pl-k">end</span></pre></div>

<p>You may also use the <code>stub_node</code> macro, which will create a new <code>Chef::Node</code> object and accepts the same parameters as the Chef Runner and a Fauxhai object:</p>

<div class="highlight highlight-ruby"><pre>www <span class="pl-k">=</span> stub_node(<span class="pl-c1">platform:</span> <span class="pl-s"><span class="pl-pds">'</span>ubuntu<span class="pl-pds">'</span></span>, <span class="pl-c1">version:</span> <span class="pl-s"><span class="pl-pds">'</span>12.04<span class="pl-pds">'</span></span>) <span class="pl-k">do </span>|<span class="pl-smi">node</span>|
        node.set[<span class="pl-s"><span class="pl-pds">'</span>attribute<span class="pl-pds">'</span></span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>value<span class="pl-pds">'</span></span>
      <span class="pl-k">end</span>

<span class="pl-c"># `www` is now a local Chef::Node object you can use in your test. To publish</span>
<span class="pl-c"># this node to the server, call `create_node`:</span>

<span class="pl-c1">ChefSpec</span>::<span class="pl-c1">ServerRunner</span>.<span class="pl-k">new</span> <span class="pl-k">do </span>|<span class="pl-smi">node</span>, <span class="pl-smi">server</span>|
  server.create_node(www)
<span class="pl-k">end</span></pre></div>

<p>Create a role:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-c1">ChefSpec</span>::<span class="pl-c1">ServerRunner</span>.<span class="pl-k">new</span> <span class="pl-k">do </span>|<span class="pl-smi">node</span>, <span class="pl-smi">server</span>|
  server.create_role(<span class="pl-s"><span class="pl-pds">'</span>my_role<span class="pl-pds">'</span></span>, { <span class="pl-c1">default_attributes:</span> {} })
<span class="pl-k">end</span></pre></div>

<p><strong>NOTE</strong> The ChefSpec server is empty at the start of each example to avoid interdependent tests.</p>

<h2>
<a id="stubbing" class="anchor" href="#stubbing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Stubbing</h2>

<h3>
<a id="command" class="anchor" href="#command" aria-hidden="true"><span class="octicon octicon-link"></span></a>Command</h3>

<p>Given a recipe with shell guard:</p>

<div class="highlight highlight-ruby"><pre>template <span class="pl-s"><span class="pl-pds">'</span>/tmp/foo.txt<span class="pl-pds">'</span></span> <span class="pl-k">do</span>
  not_if <span class="pl-s"><span class="pl-pds">'</span>grep text /tmp/foo.txt<span class="pl-pds">'</span></span>
<span class="pl-k">end</span></pre></div>

<p>ChefSpec will raise an error like:</p>

<pre lang="text"><code>Real commands are disabled. Unregistered command: `grep text /tmp/foo.txt`

You can stub this command with:

 stub_command("grep text /tmp/foo.txt").and_return(true)

============================================================
</code></pre>

<p>Just like the error message says, you must stub the command result. This can be done inside a <code>before</code> block or inside the <code>it</code> block, and the stubbing method accepts both a value or Ruby code. If provided a value, the result is static. If provided a Ruby block, the block is evaluated each time the search is called.</p>

<div class="highlight highlight-ruby"><pre>describe <span class="pl-s"><span class="pl-pds">'</span>example::default<span class="pl-pds">'</span></span> <span class="pl-k">do</span>
  let(<span class="pl-c1">:chef_run</span>) { <span class="pl-c1">ChefSpec</span>::<span class="pl-c1">SoloRunner</span>.<span class="pl-k">new</span> }

  before <span class="pl-k">do</span>
    stub_command(<span class="pl-s"><span class="pl-pds">"</span>grep text /tmp/foo.txt<span class="pl-pds">"</span></span>).and_return(<span class="pl-c1">true</span>)
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<div class="highlight highlight-ruby"><pre>describe <span class="pl-s"><span class="pl-pds">'</span>example::default<span class="pl-pds">'</span></span> <span class="pl-k">do</span>
  let(<span class="pl-c1">:chef_run</span>) { <span class="pl-c1">ChefSpec</span>::<span class="pl-c1">SoloRunner</span>.<span class="pl-k">new</span> }

  before <span class="pl-k">do</span>
    stub_command(<span class="pl-s"><span class="pl-pds">"</span>grep text /tmp/foo.txt<span class="pl-pds">"</span></span>) { rand(<span class="pl-c1">50</span>)<span class="pl-k">%</span><span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">0</span> }
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<h3>
<a id="data-bag--data-bag-item" class="anchor" href="#data-bag--data-bag-item" aria-hidden="true"><span class="octicon octicon-link"></span></a>Data Bag &amp; Data Bag Item</h3>

<p><strong>NOTE</strong> This is not required if you are using a ChefSpec server.</p>

<p>Given a recipe that executes a <code>data_bag</code> method:</p>

<div class="highlight highlight-ruby"><pre>data_bag(<span class="pl-s"><span class="pl-pds">'</span>users<span class="pl-pds">'</span></span>).each <span class="pl-k">do </span>|<span class="pl-smi">user</span>|
  data_bag_item(<span class="pl-s"><span class="pl-pds">'</span>users<span class="pl-pds">'</span></span>, user[<span class="pl-s"><span class="pl-pds">'</span>id<span class="pl-pds">'</span></span>])
<span class="pl-k">end</span></pre></div>

<p>ChefSpec will raise an error like:</p>

<pre lang="text"><code>Real data_bags are disabled. Unregistered data_bag: data_bag(:users)

You can stub this data_bag with:

  stub_data_bag("users").and_return([])

============================================================
</code></pre>

<p>Just like the error message says, you must stub the result of the <code>data_bag</code> call. This can be done inside a <code>before</code> block or inside the <code>it</code> block, and the stubbing method accepts both a value or Ruby code. If provided a value, the result is static. If provided a Ruby block, the block is evaluated each time the search is called.</p>

<div class="highlight highlight-ruby"><pre>describe <span class="pl-s"><span class="pl-pds">'</span>example::default<span class="pl-pds">'</span></span> <span class="pl-k">do</span>
  let(<span class="pl-c1">:chef_run</span>) { <span class="pl-c1">ChefSpec</span>::<span class="pl-c1">SoloRunner</span>.<span class="pl-k">new</span> }

  before <span class="pl-k">do</span>
    stub_data_bag(<span class="pl-s"><span class="pl-pds">'</span>users<span class="pl-pds">'</span></span>).and_return([])
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<div class="highlight highlight-ruby"><pre>describe <span class="pl-s"><span class="pl-pds">'</span>example::default<span class="pl-pds">'</span></span> <span class="pl-k">do</span>
  let(<span class="pl-c1">:chef_run</span>) { <span class="pl-c1">ChefSpec</span>::<span class="pl-c1">SoloRunner</span>.<span class="pl-k">new</span> }

  before <span class="pl-k">do</span>
    stub_data_bag(<span class="pl-s"><span class="pl-pds">'</span>users<span class="pl-pds">'</span></span>).and_return([<span class="pl-s"><span class="pl-pds">'</span>svargo<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>francis<span class="pl-pds">'</span></span>])

    stub_data_bag_item(<span class="pl-s"><span class="pl-pds">'</span>users<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>svargo<span class="pl-pds">'</span></span>).and_return({ ... })
    stub_data_bag_item(<span class="pl-s"><span class="pl-pds">'</span>users<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>francis<span class="pl-pds">'</span></span>) { (ruby code) }
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>If you are using <strong>Encrypted Data Bag Items</strong>, you'll need to dive into the RSpec layer and stub that class method instead:</p>

<div class="highlight highlight-ruby"><pre>describe <span class="pl-s"><span class="pl-pds">'</span>example::default<span class="pl-pds">'</span></span> <span class="pl-k">do</span>
  before <span class="pl-k">do</span>
    allow(<span class="pl-c1">Chef</span>::<span class="pl-c1">EncryptedDataBagItem</span>).to receive(<span class="pl-c1">:load</span>).with(<span class="pl-s"><span class="pl-pds">'</span>users<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>svargo<span class="pl-pds">'</span></span>).and_return(...)
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<h3>
<a id="search" class="anchor" href="#search" aria-hidden="true"><span class="octicon octicon-link"></span></a>Search</h3>

<p><strong>NOTE</strong> This is not required if you are using a ChefSpec server.</p>

<p>Because ChefSpec is a unit-testing framework, it is recommended that all third-party API calls be mocked or stubbed. ChefSpec exposes a helpful RSpec macro for stubbing search results in your tests. If you converge a Chef recipe that implements a <code>search</code> call, ChefSpec will throw an error like:</p>

<pre lang="text"><code>Real searches are disabled. Unregistered search: search(:node, 'name:hello')

You can stub this search with:

  stub_search(:node, 'name:hello') {  }

============================================================
</code></pre>

<p>Just like the error message says, you must stub the search result. This can be done inside a <code>before</code> block or inside the <code>it</code> block, and the stubbing method accepts both a value or Ruby code. If provided a value, the result is static. If provided a Ruby block, the block is evaluated each time the search is called.</p>

<div class="highlight highlight-ruby"><pre>describe <span class="pl-s"><span class="pl-pds">'</span>example::default<span class="pl-pds">'</span></span> <span class="pl-k">do</span>
  let(<span class="pl-c1">:chef_run</span>) { <span class="pl-c1">ChefSpec</span>::<span class="pl-c1">SoloRunner</span>.<span class="pl-k">new</span> }

  before <span class="pl-k">do</span>
    stub_search(<span class="pl-c1">:node</span>, <span class="pl-s"><span class="pl-pds">'</span>name:hello<span class="pl-pds">'</span></span>).and_return([])
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<div class="highlight highlight-ruby"><pre>describe <span class="pl-s"><span class="pl-pds">'</span>example::default<span class="pl-pds">'</span></span> <span class="pl-k">do</span>
  let(<span class="pl-c1">:chef_run</span>) { <span class="pl-c1">ChefSpec</span>::<span class="pl-c1">SoloRunner</span>.<span class="pl-k">new</span> }

  before <span class="pl-k">do</span>
    stub_search(<span class="pl-c1">:node</span>, <span class="pl-s"><span class="pl-pds">'</span>name:hello<span class="pl-pds">'</span></span>) { (ruby_code) }
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<h2>
<a id="reporting" class="anchor" href="#reporting" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reporting</h2>

<p>ChefSpec can generate a report of resources read over resources tested.</p>

<p>To generate the coverage report, add the following to your <code>spec_helper.rb</code> before you require any "Chef" code:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">'</span>chefspec<span class="pl-pds">'</span></span>
<span class="pl-c1">ChefSpec</span>::<span class="pl-c1">Coverage</span>.start!

<span class="pl-c"># Existing spec_helper contents...</span></pre></div>

<p>By default, that method will output helpful information to standard out:</p>

<pre lang="text"><code>ChefSpec Coverage report generated...

  Total Resources:   6
  Touched Resources: 1
  Touch Coverage:    16.67%

Untouched Resources:

  package[git]               bacon/recipes/default.rb:2
  package[build-essential]   bacon/recipes/default.rb:3
  package[apache2]           bacon/recipes/default.rb:4
  package[libvrt]            bacon/recipes/default.rb:5
  package[core]              bacon/recipes/default.rb:6
</code></pre>

<p>By default, ChefSpec will test all cookbooks that are loaded as part of the Chef Client run. If you have a cookbook with many dependencies, this may be less than desireable. To restrict coverage reporting against certain cookbooks, <code>ChefSpec::Coverage</code> yields a block:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-c1">ChefSpec</span>::<span class="pl-c1">Coverage</span>.start! <span class="pl-k">do</span>
  add_filter <span class="pl-s"><span class="pl-pds">'</span>vendor/cookbooks<span class="pl-pds">'</span></span>
<span class="pl-k">end</span></pre></div>

<p>The <code>add_filter</code> method accepts a variety of objects. For example:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-c1">ChefSpec</span>::<span class="pl-c1">Coverage</span>.start! <span class="pl-k">do</span>
  <span class="pl-c"># Strings are interpreted as file paths, with a forward anchor</span>
  add_filter <span class="pl-s"><span class="pl-pds">'</span>vendor/cookbooks<span class="pl-pds">'</span></span>

  <span class="pl-c"># Regular expressions must be escaped, but provide a nicer API for negative</span>
  <span class="pl-c"># back tracking</span>
  add_filter <span class="pl-k">/</span>cookbooks\<span class="pl-k">/</span>(<span class="pl-c1">?!</span>omnibus)<span class="pl-k">/</span>

  <span class="pl-c"># Custom block filters yield a {Chef::Resource} object - if the block</span>
  <span class="pl-c"># evaluates to true, it will be filtered</span>
  add_filter <span class="pl-k">do </span>|<span class="pl-smi">resource</span>|
    <span class="pl-c"># Bob's cookbook's are completely untested! Ignore them until he gets his</span>
    <span class="pl-c"># shit together.</span>
    resource.source_file <span class="pl-k">=~</span> <span class="pl-sr"><span class="pl-pds">/</span>cookbooks<span class="pl-cce">\/</span>bob-<span class="pl-sr">(.+)</span><span class="pl-pds">/</span></span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>For more complex scenarios, you can create a custom <code>Filter</code> object that inherits from <code>ChefSpec::Coverage::Filter</code> and implements the <code>matches?</code> method.</p>

<div class="highlight highlight-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">CustomFilter<span class="pl-e"> &lt; ChefSpec::Coverage::Filter</span></span>
  <span class="pl-k">def</span> <span class="pl-en">initialize</span>(<span class="pl-smi">arg1</span>, <span class="pl-smi">arg2</span>, <span class="pl-k">&amp;</span><span class="pl-smi">block</span>)
    <span class="pl-c"># Create a custom initialization method, do some magic, etc.</span>
  <span class="pl-k">end</span>

  <span class="pl-k">def</span> <span class="pl-en">matches?</span>(<span class="pl-smi">resource</span>)
    <span class="pl-c"># Custom matching logic in here - anything that evaluates to "true" will be</span>
    <span class="pl-c"># filtered.</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c1">ChefSpec</span>::<span class="pl-c1">Coverage</span>.start! <span class="pl-k">do</span>
  add_filter <span class="pl-c1">CustomFilter</span>.<span class="pl-k">new</span>(<span class="pl-s"><span class="pl-pds">'</span>foo<span class="pl-pds">'</span></span>, <span class="pl-c1">:bar</span>)
<span class="pl-k">end</span></pre></div>

<p>If you are using ChefSpec's Berkshelf plugin, a filter is automatically created for you. If you would like to ignore that filter, you can <code>clear</code> all the filters before defining your own:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-c1">ChefSpec</span>::<span class="pl-c1">Coverage</span>.start! <span class="pl-k">do</span>
  filters.clear

  <span class="pl-c"># Add your custom filters now</span>
<span class="pl-k">end</span></pre></div>

<h2>
<a id="mocking-out-environments" class="anchor" href="#mocking-out-environments" aria-hidden="true"><span class="octicon octicon-link"></span></a>Mocking Out Environments</h2>

<p>If you want to mock out <code>node.chef_environment</code>, you'll need to use RSpec mocks/stubs twice:</p>

<div class="highlight highlight-ruby"><pre>let(<span class="pl-c1">:chef_run</span>) <span class="pl-k">do</span>
  <span class="pl-c1">ChefSpec</span>::<span class="pl-c1">SoloRunner</span>.<span class="pl-k">new</span> <span class="pl-k">do </span>|<span class="pl-smi">node</span>|
    <span class="pl-c"># Create a new environment (you could also use a different :let block or :before block)</span>
    env <span class="pl-k">=</span> <span class="pl-c1">Chef</span>::<span class="pl-c1">Environment</span>.<span class="pl-k">new</span>
    env.name <span class="pl-s"><span class="pl-pds">'</span>staging<span class="pl-pds">'</span></span>

    <span class="pl-c"># Stub the node to return this environment</span>
    allow(node).to receive(<span class="pl-c1">:chef_environment</span>).and_return(env.name)

    <span class="pl-c"># Stub any calls to Environment.load to return this environment</span>
    allow(<span class="pl-c1">Chef</span>::<span class="pl-c1">Environment</span>).to receive(<span class="pl-c1">:load</span>).and_return(env)
  <span class="pl-k">end</span>.converge(<span class="pl-s"><span class="pl-pds">'</span>cookbook::recipe<span class="pl-pds">'</span></span>)
<span class="pl-k">end</span></pre></div>

<p><strong>There is probably a better/easier way to do this. If you have a better solution, please open an issue or Pull Request so we can make this less painful :)</strong></p>

<h2>
<a id="testing-lwrps" class="anchor" href="#testing-lwrps" aria-hidden="true"><span class="octicon octicon-link"></span></a>Testing LWRPs</h2>

<p><strong>WARNING</strong> Cookbooks with dashes (hyphens) are difficult to test with ChefSpec because of how Chef classifies objects. We recommend naming cookbooks with underscores (<code>_</code>) instead of dashes (<code>-</code>).</p>

<p>ChefSpec overrides all providers to take no action (otherwise it would actually converge your system). This means that the steps inside your LWRP are not actually executed. If an LWRP performs actions, those actions are never executed or added to the resource collection.</p>

<p>In order to run the actions exposed by your LWRP, you have to explicitly tell the <code>Runner</code> to step into it:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">'</span>chefspec<span class="pl-pds">'</span></span>

describe <span class="pl-s"><span class="pl-pds">'</span>foo::default<span class="pl-pds">'</span></span> <span class="pl-k">do</span>
  let(<span class="pl-c1">:chef_run</span>) <span class="pl-k">do</span>
    <span class="pl-c1">ChefSpec</span>::<span class="pl-c1">SoloRunner</span>.<span class="pl-k">new</span>(<span class="pl-c1">step_into:</span> [<span class="pl-s"><span class="pl-pds">'</span>my_lwrp<span class="pl-pds">'</span></span>]).converge(<span class="pl-s"><span class="pl-pds">'</span>foo::default<span class="pl-pds">'</span></span>)
  <span class="pl-k">end</span>

  it <span class="pl-s"><span class="pl-pds">'</span>installs the foo package through my_lwrp<span class="pl-pds">'</span></span> <span class="pl-k">do</span>
    expect(chef_run).to install_package(<span class="pl-s"><span class="pl-pds">'</span>foo<span class="pl-pds">'</span></span>)
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p><strong>NOTE:</strong> If your cookbook exposes LWRPs, it is highly recommended you also create a <code>libraries/matchers.rb</code> file as outlined below in the "Packaging Custom Matchers" section. <strong>You should never <code>step_into</code> an LWRP unless you are testing it. Never <code>step_into</code> an LWRP from another cookbook!</strong></p>

<h2>
<a id="packaging-custom-matchers" class="anchor" href="#packaging-custom-matchers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Packaging Custom Matchers</h2>

<p>ChefSpec exposes the ability for cookbook authors to package custom matchers inside a cookbook so that other developers may take advantage of them in testing. This is done by creating a special library file in the cookbook named <code>matchers.rb</code>:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-c"># cookbook/libraries/matchers.rb</span>

<span class="pl-k">if</span> <span class="pl-k">defined?</span>(<span class="pl-c1">ChefSpec</span>)
  <span class="pl-k">def</span> <span class="pl-en">my_custom_matcher</span>(<span class="pl-smi">resource_name</span>)
    <span class="pl-c1">ChefSpec</span>::<span class="pl-c1">Matchers</span>::<span class="pl-c1">ResourceMatcher</span>.<span class="pl-k">new</span>(resource, action, resource_name)
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<ol>
<li>The entire contents of this file must be wrapped with the conditional clause checking if <code>ChefSpec</code> is defined.</li>
<li>
<p>Each matcher is actually a top-level method. The above example corresponds to the following RSpec test:</p>

<div class="highlight highlight-ruby"><pre>expect(chef_run).to my_custom_matcher(<span class="pl-s"><span class="pl-pds">'</span>...<span class="pl-pds">'</span></span>)</pre></div>
</li>
<li>
<p><code>ChefSpec::Matchers::ResourceMatcher</code> accepts three parameters:</p>

<ol>
<li>The name of the resource to find in the resource collection (i.e. the name of the LWRP).</li>
<li>The action that resource should receive.</li>
<li>The value of the name attribute of the resource to find. (This is typically proxied as the value from the matcher definition.)</li>
</ol>
</li>
</ol>

<p>ChefSpec's built-in <code>ResourceMatcher</code> <em>should</em> satisfy most common use cases for packaging a custom matcher with your LWRPs. However, if your cookbook is extending Chef core or is outside of the scope of a traditional "resource", you may need to create a custom matcher. For more information on custom matchers in RSpec, please <a href="http://railscasts.com/episodes/157-rspec-matchers-macros">watch the Railscast on Custom Matchers</a> or look at some of the other custom matchers in ChefSpec's source code.</p>

<h4>
<a id="example" class="anchor" href="#example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Example</h4>

<p>Suppose I have a cookbook named "motd" with a resource/provider "message".</p>

<div class="highlight highlight-ruby"><pre><span class="pl-c"># motd/resources/message.rb</span>
actions <span class="pl-c1">:write</span>
default_action <span class="pl-c1">:write</span>

attribute <span class="pl-c1">:message</span>, <span class="pl-c1">name_attribute:</span> <span class="pl-c1">true</span></pre></div>

<div class="highlight highlight-ruby"><pre><span class="pl-c"># motd/providers/message.rb</span>
action <span class="pl-c1">:write</span> <span class="pl-k">do</span>
  <span class="pl-c"># ...</span>
<span class="pl-k">end</span></pre></div>

<p>Chef will dynamically build the <code>motd_message</code> LWRP at runtime that can be used in the recipe DSL:</p>

<div class="highlight highlight-ruby"><pre>motd_message <span class="pl-s"><span class="pl-pds">'</span>my message<span class="pl-pds">'</span></span></pre></div>

<p>You can package a custom ChefSpec matcher with the motd cookbook by including the following code in <code>libraries/matchers.rb</code>:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-c"># motd/libraries/matchers.rb</span>
<span class="pl-k">if</span> <span class="pl-k">defined?</span>(<span class="pl-c1">ChefSpec</span>)
  <span class="pl-k">def</span> <span class="pl-en">write_motd_message</span>(<span class="pl-smi">message</span>)
    <span class="pl-c1">ChefSpec</span>::<span class="pl-c1">Matchers</span>::<span class="pl-c1">ResourceMatcher</span>.<span class="pl-k">new</span>(<span class="pl-c1">:motd_message</span>, <span class="pl-c1">:write</span>, message)
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>Other developers can write RSpec tests against your LWRP in their cookbooks:</p>

<div class="highlight highlight-ruby"><pre>expect(chef_run).to write_motd_message(<span class="pl-s"><span class="pl-pds">'</span>my message<span class="pl-pds">'</span></span>)</pre></div>

<p><strong>Don't forget to include documentation in your cookbook's README noting the custom matcher and its API!</strong></p>

<h2>
<a id="writing-custom-matchers" class="anchor" href="#writing-custom-matchers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Writing Custom Matchers</h2>

<p>If you are testing a cookbook that does not package its LWRP matchers, you can create your own following the same pattern as the "Packaging Custom Matchers" section. Simply, create a file at <code>spec/support/matchers.rb</code> and add your resource matchers:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-c"># spec/support/matchers.rb</span>
<span class="pl-k">def</span> <span class="pl-en">my_custom_matcher</span>(<span class="pl-smi">resource_name</span>)
  <span class="pl-c1">ChefSpec</span>::<span class="pl-c1">Matchers</span>::<span class="pl-c1">ResourceMatcher</span>.<span class="pl-k">new</span>(<span class="pl-c1">:resource</span>, <span class="pl-c1">:action</span>, resource_name)
<span class="pl-k">end</span></pre></div>

<p>Then require this file in your <code>spec_helper.rb</code> so the matcher can be used:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-k">require_relative</span> <span class="pl-s"><span class="pl-pds">'</span>support/matchers<span class="pl-pds">'</span></span></pre></div>

<p>Please use this as a <em>temporary</em> solution. Consider sending a Pull Request to the LWRP author(s) packaging the custom resource matchers (see previous section).</p>

<p>ChefSpec also provides a helper method to define a method on the Chef runner for locating a resource in the collection. This is helpful while asserting against custom resource notifications.</p>

<div class="highlight highlight-ruby"><pre><span class="pl-c"># matchers.rb</span>
<span class="pl-c1">ChefSpec</span>.define_matcher <span class="pl-c1">:my_custom_resource</span></pre></div>

<p>And then in your spec suite, you can obtain the custom resource for assertions:</p>

<div class="highlight highlight-ruby"><pre>let(<span class="pl-c1">:chef_run</span>) { <span class="pl-c1">ChefSpec</span>::<span class="pl-c1">SoloRunner</span>.converge(<span class="pl-s"><span class="pl-pds">'</span>...<span class="pl-pds">'</span></span>) }

it <span class="pl-s"><span class="pl-pds">'</span>notifies the thing<span class="pl-pds">'</span></span> <span class="pl-k">do</span>
  custom <span class="pl-k">=</span> chef_run.my_custom_resource(<span class="pl-s"><span class="pl-pds">'</span>name<span class="pl-pds">'</span></span>)
  expect(custom).to notify(<span class="pl-s"><span class="pl-pds">'</span>service[apache2]<span class="pl-pds">'</span></span>).to(<span class="pl-c1">:restart</span>).immediately
<span class="pl-k">end</span></pre></div>

<h2>
<a id="expecting-exceptions" class="anchor" href="#expecting-exceptions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Expecting Exceptions</h2>

<p>In Chef 11, custom formatters were introduced and ChefSpec uses a custom formatter to suppress Chef Client output. In the event of a convergence failure, ChefSpec will output the error message from the run to help you debug:</p>

<pre lang="text"><code>================================================================================
Recipe Compile Error in apt_package/recipes/install.rb
================================================================================

RuntimeError
------------
RuntimeError

Cookbook Trace:
---------------
  .../apt_package/recipes/install.rb:1:in `from_file'
  .../apt_package/spec/install_spec.rb:4:in `block (2 levels) in &lt;top (required)&gt;'
  .../apt_package/spec/install_spec.rb:7:in `block (2 levels) in &lt;top (required)&gt;'

Relevant File Content:
----------------------
.../apt_package/recipes/install.rb:

  1&gt;&gt; raise RuntimeError
  2:
  3:  apt_package 'default_action'
</code></pre>

<p>This output is automatically silenced when using RSpec's <code>raise_error</code> matcher:</p>

<div class="highlight highlight-ruby"><pre>let(<span class="pl-c1">:chef_run</span>) { <span class="pl-c1">ChefSpec</span>::<span class="pl-c1">SoloRunner</span>.converge(<span class="pl-s"><span class="pl-pds">'</span>cookbook::recipe<span class="pl-pds">'</span></span>) }

it <span class="pl-s"><span class="pl-pds">'</span>raises an error<span class="pl-pds">'</span></span> <span class="pl-k">do</span>
  expect {
    chef_run
  }.to raise_error
<span class="pl-k">end</span></pre></div>

<p>You can also assert that a particular error was raised. If the error matches the given type, the output is suppressed. If not, the test fails and the entire stack trace is presented.</p>

<div class="highlight highlight-ruby"><pre>let(<span class="pl-c1">:chef_run</span>) { <span class="pl-c1">ChefSpec</span>::<span class="pl-c1">SoloRunner</span>.converge(<span class="pl-s"><span class="pl-pds">'</span>cookbook::recipe<span class="pl-pds">'</span></span>) }

it <span class="pl-s"><span class="pl-pds">'</span>raises an error<span class="pl-pds">'</span></span> <span class="pl-k">do</span>
  expect {
    chef_run
  }.to raise_error(<span class="pl-c1">RuntimeError</span>)
<span class="pl-k">end</span></pre></div>

<h2>
<a id="testing-roles" class="anchor" href="#testing-roles" aria-hidden="true"><span class="octicon octicon-link"></span></a>Testing Roles</h2>

<p>Even though ChefSpec is cookbook-centric, you can still converge multiple recipes and roles in a single <code>ChefSpec::SoloRunner</code> instance. Given a cookbook "bacon" with a default recipe:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-c"># cookbooks/bacon/recipes/default.rb</span>
package <span class="pl-s"><span class="pl-pds">'</span>foo<span class="pl-pds">'</span></span></pre></div>

<p>and a default attributes file:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-c"># cookbooks/bacon/attributes/default.rb</span>
default[<span class="pl-s"><span class="pl-pds">'</span>bacon<span class="pl-pds">'</span></span>][<span class="pl-s"><span class="pl-pds">'</span>temperature<span class="pl-pds">'</span></span>] <span class="pl-k">=</span> <span class="pl-c1">200</span></pre></div>

<p>and a role "breakfast":</p>

<div class="highlight highlight-ruby"><pre><span class="pl-c"># roles/breakfast.rb</span>
default_attributes(
  <span class="pl-s"><span class="pl-pds">'</span>bacon<span class="pl-pds">'</span></span> =&gt; {
    <span class="pl-s"><span class="pl-pds">'</span>temperature<span class="pl-pds">'</span></span> =&gt; <span class="pl-c1">150</span> <span class="pl-c"># NOTE: This is different from the default value</span>
  }
)
run_list([
  <span class="pl-s"><span class="pl-pds">'</span>recipe[bacon::default]<span class="pl-pds">'</span></span>
])</pre></div>

<p>You can test that the role is appropriately applied by telling the <code>ChefSpec::SoloRunner</code> to converge on the <em>role</em> instead of a recipe:</p>

<div class="highlight highlight-ruby"><pre>let(<span class="pl-c1">:chef_run</span>) { <span class="pl-c1">ChefSpec</span>::<span class="pl-c1">SoloRunner</span>.converge(<span class="pl-s"><span class="pl-pds">'</span>role[breakfast]<span class="pl-pds">'</span></span>) }</pre></div>

<p>Assert that the run_list is properly expanded:</p>

<div class="highlight highlight-ruby"><pre>expect(chef_run).to include_recipe(<span class="pl-s"><span class="pl-pds">'</span>bacon::default<span class="pl-pds">'</span></span>)</pre></div>

<p>Assert that the correct attribute is used:</p>

<div class="highlight highlight-ruby"><pre>expect(chef_run.node[<span class="pl-s"><span class="pl-pds">'</span>bacon<span class="pl-pds">'</span></span>][<span class="pl-s"><span class="pl-pds">'</span>temperature<span class="pl-pds">'</span></span>]).to eq(<span class="pl-c1">150</span>)</pre></div>

<p><strong>NOTE</strong> If your roles live somewhere outside of the expected path, you must set <code>RSpec.config.role_path</code> to point to the directory containing your roles <strong>before</strong> invoking the <code>#converge</code> method!</p>

<div class="highlight highlight-ruby"><pre><span class="pl-c1">RSpec</span>.configure <span class="pl-k">do </span>|<span class="pl-smi">config</span>|
  config.role_path <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>/var/my/roles<span class="pl-pds">'</span></span> <span class="pl-c"># global setting</span>
<span class="pl-k">end</span>

<span class="pl-c"># - OR -</span>

<span class="pl-c1">ChefSpec</span>::<span class="pl-c1">SoloRunner</span>.<span class="pl-k">new</span>(<span class="pl-c1">role_path:</span> <span class="pl-s"><span class="pl-pds">'</span>/var/my/roles<span class="pl-pds">'</span></span>) <span class="pl-c"># local setting</span></pre></div>

<h2>
<a id="faster-specs" class="anchor" href="#faster-specs" aria-hidden="true"><span class="octicon octicon-link"></span></a>Faster Specs</h2>

<p>ChefSpec aims to provide the easiest and simplest path for new users to write RSpec examples for Chef cookbooks. In doing so, it makes some sacrifices in terms of speed and agility of execution. In other words, ChefSpec favors "speed to develop" over "speed to execute". Many of these decisions are directly related to the way Chef dynamically loads resources at runtime.</p>

<p>If you understand how RSpec works and would like to see some significant speed improvements in your specs, you can use the <code>ChefSpec::Cacher</code> module inspired by <a href="https://github.com/DracoAter">Juri Timošin</a>. Simply convert all your <code>let</code> blocks to <code>cached</code>:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-c"># before</span>
let(<span class="pl-c1">:chef_run</span>) { <span class="pl-c1">ChefSpec</span>::<span class="pl-c1">SoloRunner</span>.<span class="pl-k">new</span> }

<span class="pl-c"># after</span>
cached(<span class="pl-c1">:chef_run</span>) { <span class="pl-c1">ChefSpec</span>::<span class="pl-c1">SoloRunner</span>.<span class="pl-k">new</span> }</pre></div>

<p>Everything else should work the same. Be advised, as the method name suggests, this will cache the results of your Chef Client Run for the <strong>entire RSpec example</strong>. This makes stubbing more of a challenge, since the node is already converged. For more information, please see <a href="http://dracoater.blogspot.com/2013/12/testing-chef-cookbooks-part-25-speeding.html">Juri Timošin's blog post on faster specs</a> as well as the discussion in <a href="https://github.com/sethvargo/chefspec/issues/275">#275</a>.</p>

<h2>
<a id="media--third-party-tutorials" class="anchor" href="#media--third-party-tutorials" aria-hidden="true"><span class="octicon octicon-link"></span></a>Media &amp; Third-party Tutorials</h2>

<ul>
<li><a href="http://technology.customink.com/blog/2012/08/03/testing-chef-cookbooks/">CustomInk's Testing Chef Cookbooks</a></li>
<li><a href="http://files.meetup.com/1780846/ChefSpec.pdf">Jake Vanderdray's Practical ChefSpec</a></li>
<li><a href="http://www.youtube.com/watch?v=o2e0aZUAVGw">Jim Hopp's excellent Test Driven Development for Chef Practitioners</a></li>
<li><a href="http://jtimberman.housepub.org/blog/2013/05/09/starting-chefspec-example/">Joshua Timberman's Starting ChefSpec Examples</a></li>
<li><a href="http://dracoater.blogspot.com/2013/12/testing-chef-cookbooks-part-25-speeding.html">Juri Timošin's post on faster specs</a></li>
<li><a href="https://sethvargo.com/chef-recipe-code-coverage/">Seth Vargo's Chef recipe code coverage</a></li>
<li><a href="http://www.confreaks.com/videos/2364-mwrc2013-tdding-tmux">Seth Vargo's TDDing tmux talk</a></li>
<li><a href="http://shop.oreilly.com/product/0636920030973.do">Stephen Nelson Smith's Test-Driven Infrastructure with Chef</a></li>
</ul>

<h2>
<a id="development" class="anchor" href="#development" aria-hidden="true"><span class="octicon octicon-link"></span></a>Development</h2>

<ol>
<li>Fork the repository from GitHub.</li>
<li>
<p>Clone your fork to your local machine:</p>

<pre><code>$ git clone git@github.com:USER/chefspec.git
</code></pre>
</li>
<li>
<p>Create a git branch</p>

<pre><code>$ git checkout -b my_bug_fix
</code></pre>
</li>
<li><p><strong>Write tests</strong></p></li>
<li>Make your changes/patches/fixes, committing appropriately</li>
<li>Run the tests: <code>bundle exec rake</code>
</li>
<li>Push your changes to GitHub</li>
<li>Open a Pull Request</li>
</ol>

<p>ChefSpec is on <a href="http://travis-ci.org/sethvargo/chefspec">Travis CI</a> which tests against multiple Chef and Ruby versions.</p>

<p>If you are contributing, please see the <a href="https://github.com/sethvargo/chefspec/blob/master/CONTRIBUTING.md">Contributing Guidelines</a> for more information.</p>

<h2>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span class="octicon octicon-link"></span></a>License</h2>

<p>MIT - see the accompanying <a href="https://github.com/sethvargo/chefspec/blob/master/LICENSE">LICENSE</a> file for details.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/sethvargo/chefspec">ChefSpec</a> is maintained by <a href="https://github.com/sethvargo">sethvargo</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>

